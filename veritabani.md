Supabase seçimi bu proje için mükemmel bir karar.

Neden?

PostgreSQL Gücü: Arkada dünyanın en gelişmiş açık kaynak veritabanı var.

Auth (Kimlik Doğrulama): "Şifremi unuttum", "Mail ile giriş" gibi akışları kodlamanıza gerek yok, Supabase içinde hazır.

Realtime: Birisi bilet aldığında admin panelinin anlık güncellenmesi için ekstra kod (WebSocket) yazmanıza gerek kalmaz.

Row Level Security (RLS): Veri güvenliğini kodda değil, doğrudan veritabanı seviyesinde yapabiliriz. (Örn: "Ahmet sadece kendi biletini görebilsin" kuralını veritabanına yazarız).

Aşağıda, önceki mimariyi Supabase (PostgreSQL) standartlarına ve güvenlik yapısına (RLS) göre revize ettim. Bunu direkt Supabase SQL Editor kısmına yapıştırıp çalıştırabilirsiniz.

SUPABASE VERİTABANI VE GÜVENLİK TASARIMI
1. Tablolar (PostgreSQL & Supabase Auth Entegrasyonu)
Supabase'de kullanıcılar auth.users tablosunda tutulur. Bizim oluşturacağımız profiles tablosu bu tabloyla eşleşecektir.

SQL

-- 1. ENUMLAR (Statüleri standartlaştırmak için)
CREATE TYPE event_status AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
CREATE TYPE queue_status AS ENUM ('ASIL', 'YEDEK', 'IPTAL');
CREATE TYPE payment_status AS ENUM ('WAITING', 'PAID');

-- 2. PROFILES (Kullanıcı Detayları - auth.users ile ilişkili)
CREATE TABLE public.profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY, -- Supabase Auth ID ile aynı
  tckn TEXT UNIQUE NOT NULL,
  sicil_no TEXT UNIQUE NOT NULL,
  full_name TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  is_admin BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. EVENTS (Etkinlikler)
CREATE TABLE public.events (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  banner_image TEXT, -- Storage path
  event_date TIMESTAMPTZ NOT NULL,
  location_url TEXT,
  price NUMERIC(10, 2) DEFAULT 0,
  quota_asil INT NOT NULL,
  quota_yedek INT NOT NULL,
  cut_off_date TIMESTAMPTZ NOT NULL,
  status event_status DEFAULT 'DRAFT',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. TICKET_POOL (PDF Bilet Havuzu)
CREATE TABLE public.ticket_pool (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id BIGINT REFERENCES public.events(id),
  file_name TEXT NOT NULL,      -- Örn: A1.pdf (Sıralama için önemli)
  file_path TEXT NOT NULL,      -- Supabase Storage Path
  assigned_to UUID REFERENCES public.profiles(id), -- Kime atandı?
  assigned_at TIMESTAMPTZ,
  is_assigned BOOLEAN DEFAULT FALSE
);

-- 5. BOOKINGS (Başvurular)
CREATE TABLE public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id BIGINT REFERENCES public.events(id),
  user_id UUID REFERENCES public.profiles(id),
  booking_date TIMESTAMPTZ DEFAULT NOW(),
  
  queue_status queue_status NOT NULL,
  payment_status payment_status DEFAULT 'WAITING',
  
  -- Onaylar
  consent_kvkk BOOLEAN DEFAULT FALSE,
  consent_payment BOOLEAN DEFAULT FALSE,

  -- Bir kişi bir etkinliğe tek başvuru yapabilir
  UNIQUE(event_id, user_id)
);
2. Kritik Güvenlik Fonksiyonu (Race Condition Önlemi)
Supabase'de istemci tarafından (Frontend) yapılan işlemler "First-Come First-Served" garantisi vermez. 500 kişi aynı anda basarsa kota aşılabilir. Bunu engellemek için Database Function (RPC) kullanacağız.

Frontend bu fonksiyonu şöyle çağıracak: await supabase.rpc('join_event', { event_id_param: 123 })

SQL

CREATE OR REPLACE FUNCTION join_event(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
  current_asil_count INT;
  current_yedek_count INT;
  event_record RECORD;
  user_id_var UUID;
BEGIN
  -- 1. Kullanıcıyı al (Oturum açmış kişi)
  user_id_var := auth.uid();
  IF user_id_var IS NULL THEN
    RETURN json_build_object('status', 'error', 'message', 'Giriş yapmalısınız.');
  END IF;

  -- 2. Etkinliği ve Kotaları Kilitle (ROW LOCKING - FOR UPDATE)
  SELECT * INTO event_record FROM public.events WHERE id = event_id_param FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik bulunamadı.');
  END IF;

  IF event_record.status != 'ACTIVE' THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik aktif değil.');
  END IF;

  -- 3. Zaten başvurmuş mu?
  IF EXISTS (SELECT 1 FROM public.bookings WHERE event_id = event_id_param AND user_id = user_id_var) THEN
    RETURN json_build_object('status', 'error', 'message', 'Zaten başvurunuz var.');
  END IF;

  -- 4. Asil Sayımı
  SELECT COUNT(*) INTO current_asil_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'ASIL';

  IF current_asil_count < event_record.quota_asil THEN
    -- Asil Listesine Ekle
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'ASIL', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'ASIL');
  END IF;

  -- 5. Yedek Sayımı
  SELECT COUNT(*) INTO current_yedek_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'YEDEK';

  IF current_yedek_count < event_record.quota_yedek THEN
    -- Yedek Listesine Ekle
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'YEDEK', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'YEDEK');
  END IF;

  -- 6. Kota Dolu
  RETURN json_build_object('status', 'error', 'message', 'Kontenjan dolmuştur.');
END;
$$;
3. Row Level Security (RLS) Politikaları
Supabase'de güvenlik "Kimin neyi görmeye yetkisi var?" kuralıyla sağlanır. Bu kodları çalıştırmazsanız verileriniz ya herkese açık olur ya da kimseye görünmez.

SQL

-- Önce RLS'i tablolarda aktif et
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_pool ENABLE ROW LEVEL SECURITY;

-- 1. PROFILES: Herkes kendi profilini görür, Admin herkesi görür
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles" ON public.profiles
  FOR ALL USING ( (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true );

-- 2. BOOKINGS: Kullanıcı sadece kendi başvurusunu görür, Admin hepsini görür
CREATE POLICY "Users view own bookings" ON public.bookings
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Admins manage all bookings" ON public.bookings
  FOR ALL USING ( (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true );

-- 3. TICKET POOL: Kullanıcı sadece kendine atanan bileti görür
CREATE POLICY "Users view assigned ticket" ON public.ticket_pool
  FOR SELECT USING (assigned_to = auth.uid());
  
CREATE POLICY "Admins manage tickets" ON public.ticket_pool
  FOR ALL USING ( (SELECT is_admin FROM public.profiles WHERE id = auth.uid()) = true );
4. Supabase Storage (Dosya Saklama)
Admin panelinden "Storage" kısmına gidip iki adet Bucket (Klasör) oluşturmalısınız:

Bucket Adı: event-banners

Public: YES (Afişleri herkes görebilmeli)

Bucket Adı: tickets

Public: NO (Gizli olmalı, sadece yetkili indirebilmeli)

5. Yazılımcı İçin Notlar (Dev Notes)
Auth Trigger: Yeni bir kullanıcı auth.users tablosuna (Supabase Auth) eklendiğinde, otomatik olarak public.profiles tablosuna da eklenmesi gerekir. Bunun için bir "Trigger Function" yazılmalı veya Backend tarafında kayıt anında iki tabloya da yazılmalı.

Excel Import: Admin Excel yüklediğinde, Supabase Auth API kullanılarak kullanıcılar oluşturulmalı (supabase.auth.admin.createUser) ve dönen ID ile public.profiles tablosuna detaylar yazılmalıdır.

Realtime: bookings tablosundaki değişiklikleri dinleyerek (supabase.channel('bookings').on(...)) ön yüzdeki "Kalan Kota" sayacı anlık güncellenebilir.