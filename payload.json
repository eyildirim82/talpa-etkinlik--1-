{"query":"-- ============================================\r\n-- TALPA Etkinlik Platform - CONSOLIDATED MASTER SCHEMA\r\n-- ============================================\r\n-- Description: Single source of truth for the database schema.\r\n-- Includes:\r\n-- 1. All Table Definitions (Profiles, Events, Bookings, Tickets, Ticket Pool)\r\n-- 2. Fixed RLS Policies using SECURITY DEFINER function (fixes recursion)\r\n-- 3. Optimized Admin Functions (assign_ticket with SKIP LOCKED)\r\n-- 4. Standardized Helper Functions (join_event)\r\n-- Version: 3.0.0\r\n-- Date: 2026-01-04\r\n-- ============================================\r\n\r\n-- ============================================\r\n-- 1. ENUM TYPES\r\n-- ============================================\r\n\r\nDO $$ BEGIN\r\n    CREATE TYPE event_status AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');\r\nEXCEPTION\r\n    WHEN duplicate_object THEN null;\r\nEND $$;\r\n\r\nDO $$ BEGIN\r\n    CREATE TYPE queue_status AS ENUM ('ASIL', 'YEDEK', 'IPTAL');\r\nEXCEPTION\r\n    WHEN duplicate_object THEN null;\r\nEND $$;\r\n\r\nDO $$ BEGIN\r\n    CREATE TYPE payment_status AS ENUM ('WAITING', 'PAID');\r\nEXCEPTION\r\n    WHEN duplicate_object THEN null;\r\nEND $$;\r\n\r\n-- ============================================\r\n-- 2. TABLES\r\n-- ============================================\r\n\r\n-- 2.1 PROFILES\r\nCREATE TABLE IF NOT EXISTS public.profiles (\r\n    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\r\n    full_name TEXT NOT NULL,\r\n    talpa_sicil_no TEXT, -- Legacy\r\n    sicil_no TEXT UNIQUE, -- New\r\n    tckn TEXT UNIQUE,\r\n    phone TEXT,\r\n    email TEXT UNIQUE,\r\n    role TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('admin', 'member')), -- Legacy role\r\n    is_admin BOOLEAN DEFAULT FALSE,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\r\n);\r\n\r\nCREATE INDEX IF NOT EXISTS idx_profiles_role ON public.profiles(role);\r\nCREATE INDEX IF NOT EXISTS idx_profiles_is_admin ON public.profiles(is_admin) WHERE is_admin = true;\r\nCREATE INDEX IF NOT EXISTS idx_profiles_tckn ON public.profiles(tckn);\r\n\r\n-- 2.2 EVENTS (New Structure)\r\nCREATE TABLE IF NOT EXISTS public.events (\r\n    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\r\n    title TEXT NOT NULL,\r\n    description TEXT,\r\n    banner_image TEXT,\r\n    image_url TEXT, -- Legacy support\r\n    event_date TIMESTAMP WITH TIME ZONE NOT NULL,\r\n    location TEXT, -- Legacy support\r\n    location_url TEXT,\r\n    price NUMERIC(10, 2) DEFAULT 0,\r\n    currency TEXT DEFAULT 'TL',\r\n    quota_asil INT NOT NULL DEFAULT 0,\r\n    quota_yedek INT NOT NULL DEFAULT 0,\r\n    total_quota INTEGER DEFAULT 0, -- Legacy support\r\n    cut_off_date TIMESTAMP WITH TIME ZONE,\r\n    status event_status DEFAULT 'DRAFT',\r\n    is_active BOOLEAN DEFAULT false, -- Legacy support\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\r\n);\r\n\r\nCREATE INDEX IF NOT EXISTS idx_events_status ON public.events(status);\r\nCREATE INDEX IF NOT EXISTS idx_events_date ON public.events(event_date);\r\n\r\n-- 2.3 BOOKINGS (New Queue System)\r\nCREATE TABLE IF NOT EXISTS public.bookings (\r\n    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\r\n    event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,\r\n    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,\r\n    booking_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\r\n    queue_status queue_status NOT NULL,\r\n    payment_status payment_status DEFAULT 'WAITING',\r\n    consent_kvkk BOOLEAN DEFAULT FALSE,\r\n    consent_payment BOOLEAN DEFAULT FALSE,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\r\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\r\n    UNIQUE(event_id, user_id)\r\n);\r\n\r\nCREATE INDEX IF NOT EXISTS idx_bookings_event_id ON public.bookings(event_id);\r\nCREATE INDEX IF NOT EXISTS idx_bookings_user_id ON public.bookings(user_id);\r\nCREATE INDEX IF NOT EXISTS idx_bookings_queue_status ON public.bookings(event_id, queue_status);\r\n\r\n-- 2.4 TICKET POOL\r\nCREATE TABLE IF NOT EXISTS public.ticket_pool (\r\n    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,\r\n    event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,\r\n    file_name TEXT NOT NULL,\r\n    file_path TEXT NOT NULL,\r\n    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,\r\n    assigned_at TIMESTAMP WITH TIME ZONE,\r\n    is_assigned BOOLEAN DEFAULT FALSE,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\r\n);\r\n\r\nCREATE INDEX IF NOT EXISTS idx_ticket_pool_event_id ON public.ticket_pool(event_id);\r\nCREATE INDEX IF NOT EXISTS idx_ticket_pool_assigned ON public.ticket_pool(assigned_to) WHERE assigned_to IS NOT NULL;\r\n\r\n-- 2.5 TICKETS (Legacy)\r\nCREATE TABLE IF NOT EXISTS public.tickets (\r\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\r\n    event_id BIGINT, -- Changed to BIGINT to match new events table if needed, or kept UUID if referencing old? \r\n                     -- WARNING: events.id is BIGINT now. Legacy tickets referenced UUID events. \r\n                     -- Assuming we start fresh, we make this BIGINT.\r\n    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,\r\n    seat_number TEXT,\r\n    qr_code TEXT UNIQUE,\r\n    status TEXT NOT NULL DEFAULT 'pending',\r\n    purchase_date TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,\r\n    gate TEXT,\r\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL\r\n);\r\n\r\n-- Note: We updated event_id to BIGINT to match the new events table. \r\n-- If strict legacy compatibility with UUID events is needed, this might be an issue, \r\n-- but \"Clean\" schema implies consistency.\r\n\r\n-- ============================================\r\n-- 3. VIEWS & TRIGGERS\r\n-- ============================================\r\n\r\n-- Updated_at Helper\r\nCREATE OR REPLACE FUNCTION public.handle_updated_at()\r\nRETURNS TRIGGER AS $$\r\nBEGIN\r\n    NEW.updated_at = timezone('utc'::text, now());\r\n    RETURN NEW;\r\nEND;\r\n$$ LANGUAGE plpgsql;\r\n\r\n-- Helper Triggers\r\nDROP TRIGGER IF EXISTS set_profiles_updated_at ON public.profiles;\r\nCREATE TRIGGER set_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();\r\n\r\nDROP TRIGGER IF EXISTS set_events_updated_at ON public.events;\r\nCREATE TRIGGER set_events_updated_at BEFORE UPDATE ON public.events FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();\r\n\r\nDROP TRIGGER IF EXISTS set_bookings_updated_at ON public.bookings;\r\nCREATE TRIGGER set_bookings_updated_at BEFORE UPDATE ON public.bookings FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();\r\n\r\n-- Active Event View\r\nCREATE OR REPLACE VIEW public.active_event_view AS\r\nSELECT \r\n    e.id,\r\n    e.title,\r\n    e.description,\r\n    COALESCE(e.banner_image, e.image_url) as image_url,\r\n    e.event_date,\r\n    COALESCE(e.location_url, e.location) as location,\r\n    e.price,\r\n    e.currency,\r\n    e.quota_asil + e.quota_yedek as total_quota,\r\n    CASE WHEN e.status = 'ACTIVE' THEN true ELSE false END as is_active,\r\n    e.created_at,\r\n    e.updated_at,\r\n    COALESCE(\r\n        (e.quota_asil + e.quota_yedek) - (\r\n            SELECT COUNT(*)\r\n            FROM public.bookings b\r\n            WHERE b.event_id = e.id \r\n            AND b.queue_status IN ('ASIL', 'YEDEK')\r\n        ), \r\n        e.quota_asil + e.quota_yedek\r\n    ) AS remaining_stock\r\nFROM public.events e\r\nWHERE e.status = 'ACTIVE';\r\n\r\n-- ============================================\r\n-- 4. SECURITY DEFINER FUNCTIONS (RLS FIX)\r\n-- ============================================\r\n\r\nCREATE OR REPLACE FUNCTION public.get_my_admin_status()\r\nRETURNS BOOLEAN\r\nLANGUAGE sql\r\nSTABLE\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\n  SELECT COALESCE(\r\n    (SELECT is_admin FROM profiles WHERE id = auth.uid()),\r\n    false\r\n  );\r\n$$;\r\n\r\nCOMMENT ON FUNCTION public.get_my_admin_status() IS 'RLS-safe admin check. Prevents recursion.';\r\n\r\n-- ============================================\r\n-- 5. FUNCTIONAL LOGIC\r\n-- ============================================\r\n\r\n-- JOIN EVENT\r\nCREATE OR REPLACE FUNCTION public.join_event(p_event_id BIGINT)\r\nRETURNS JSON\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_current_asil_count INT;\r\n  v_current_yedek_count INT;\r\n  v_event_record RECORD;\r\n  v_user_id UUID;\r\nBEGIN\r\n  v_user_id := auth.uid();\r\n  IF v_user_id IS NULL THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'AUTH_REQUIRED', 'message', 'Giriş yapmalısınız.');\r\n  END IF;\r\n\r\n  SELECT * INTO v_event_record FROM events WHERE id = p_event_id FOR UPDATE;\r\n  \r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'EVENT_NOT_FOUND', 'message', 'Etkinlik bulunamadı.');\r\n  END IF;\r\n\r\n  IF v_event_record.status != 'ACTIVE' THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'EVENT_NOT_ACTIVE', 'message', 'Etkinlik aktif değil.');\r\n  END IF;\r\n\r\n  IF v_event_record.cut_off_date IS NOT NULL AND NOW() > v_event_record.cut_off_date THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'REGISTRATION_CLOSED', 'message', 'Başvuru süresi sona ermiştir.');\r\n  END IF;\r\n\r\n  IF EXISTS (SELECT 1 FROM bookings WHERE event_id = p_event_id AND user_id = v_user_id) THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'ALREADY_REGISTERED', 'message', 'Zaten bu etkinliğe başvurunuz var.');\r\n  END IF;\r\n\r\n  SELECT COUNT(*) INTO v_current_asil_count FROM bookings WHERE event_id = p_event_id AND queue_status = 'ASIL';\r\n\r\n  IF v_current_asil_count < v_event_record.quota_asil THEN\r\n    INSERT INTO bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)\r\n    VALUES (p_event_id, v_user_id, 'ASIL', true, true);\r\n    \r\n    RETURN json_build_object('success', true, 'queue', 'ASIL', 'position', v_current_asil_count + 1, 'message', 'Başvurunuz alındı. Asil listedesiniz.');\r\n  END IF;\r\n\r\n  SELECT COUNT(*) INTO v_current_yedek_count FROM bookings WHERE event_id = p_event_id AND queue_status = 'YEDEK';\r\n\r\n  IF v_current_yedek_count < v_event_record.quota_yedek THEN\r\n    INSERT INTO bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)\r\n    VALUES (p_event_id, v_user_id, 'YEDEK', true, true);\r\n    \r\n    RETURN json_build_object('success', true, 'queue', 'YEDEK', 'position', v_current_yedek_count + 1, 'message', 'Başvurunuz alındı. Yedek listedesiniz.');\r\n  END IF;\r\n\r\n  RETURN json_build_object('success', false, 'error_code', 'QUOTA_FULL', 'message', 'Kontenjan dolmuştur.');\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'INTERNAL_ERROR', 'message', 'Hata oluştu.', 'details', SQLERRM);\r\nEND;\r\n$$;\r\n\r\n-- ASSIGN TICKET (Optimized)\r\nCREATE OR REPLACE FUNCTION public.assign_ticket(p_booking_id BIGINT)\r\nRETURNS JSON\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_booking_record RECORD;\r\n  v_ticket_record RECORD;\r\nBEGIN\r\n  IF NOT public.get_my_admin_status() THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'UNAUTHORIZED', 'message', 'Yetkiniz yok.');\r\n  END IF;\r\n\r\n  SELECT * INTO v_booking_record FROM bookings \r\n  WHERE id = p_booking_id AND payment_status = 'WAITING'\r\n  FOR UPDATE SKIP LOCKED; -- Optimization\r\n\r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'BOOKING_NOT_FOUND', 'message', 'Başvuru bulunamadı veya işlemde.');\r\n  END IF;\r\n\r\n  SELECT * INTO v_ticket_record FROM ticket_pool\r\n  WHERE event_id = v_booking_record.event_id AND is_assigned = false\r\n  ORDER BY file_name ASC LIMIT 1\r\n  FOR UPDATE SKIP LOCKED;\r\n\r\n  IF NOT FOUND THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'NO_TICKETS_AVAILABLE', 'message', 'Bilet yok.');\r\n  END IF;\r\n\r\n  UPDATE ticket_pool SET assigned_to = v_booking_record.user_id, assigned_at = NOW(), is_assigned = true WHERE id = v_ticket_record.id;\r\n  UPDATE bookings SET payment_status = 'PAID' WHERE id = p_booking_id;\r\n\r\n  RETURN json_build_object('success', true, 'ticket_id', v_ticket_record.id, 'file_path', v_ticket_record.file_path, 'message', 'Bilet atandı.');\r\nEXCEPTION\r\n  WHEN OTHERS THEN\r\n    RETURN json_build_object('success', false, 'error_code', 'INTERNAL_ERROR', 'message', 'Hata oluştu.', 'details', SQLERRM);\r\nEND;\r\n$$;\r\n\r\n-- SET ACTIVE EVENT\r\nCREATE OR REPLACE FUNCTION public.set_active_event(p_event_id BIGINT)\r\nRETURNS JSON\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_exists BOOLEAN;\r\nBEGIN\r\n  IF NOT public.get_my_admin_status() THEN\r\n    RETURN json_build_object('success', false, 'message', 'Yetkiniz yok.');\r\n  END IF;\r\n  \r\n  SELECT EXISTS (SELECT 1 FROM events WHERE id = p_event_id) INTO v_exists;\r\n  \r\n  IF NOT v_exists THEN\r\n    RETURN json_build_object('success', false, 'message', 'Etkinlik bulunamadı.');\r\n  END IF;\r\n  \r\n  UPDATE events SET status = 'ARCHIVED' WHERE status = 'ACTIVE';\r\n  UPDATE events SET status = 'ACTIVE' WHERE id = p_event_id;\r\n  \r\n  RETURN json_build_object('success', true, 'message', 'Etkinlik aktif edildi.');\r\nEND;\r\n$$;\r\n\r\n-- ============================================\r\n-- 6. RLS POLICIES\r\n-- ============================================\r\n\r\nALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.events ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.ticket_pool ENABLE ROW LEVEL SECURITY;\r\nALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;\r\n\r\n-- Clean existing policies\r\nDROP POLICY IF EXISTS \"Users can view own profile\" ON public.profiles;\r\nDROP POLICY IF EXISTS \"Users can update own profile\" ON public.profiles;\r\nDROP POLICY IF EXISTS \"Admins can view all profiles\" ON public.profiles; \r\nDROP POLICY IF EXISTS \"Admins can update any profile\" ON public.profiles;\r\n\r\nDROP POLICY IF EXISTS \"Anyone can view active events\" ON public.events;\r\nDROP POLICY IF EXISTS \"Admins can view all events\" ON public.events;\r\nDROP POLICY IF EXISTS \"Admins can insert events\" ON public.events;\r\nDROP POLICY IF EXISTS \"Admins can update events\" ON public.events;\r\nDROP POLICY IF EXISTS \"Admins can delete events\" ON public.events;\r\n\r\nDROP POLICY IF EXISTS \"Users view own bookings\" ON public.bookings;\r\nDROP POLICY IF EXISTS \"Admins manage all bookings\" ON public.bookings;\r\n\r\nDROP POLICY IF EXISTS \"Users view assigned ticket\" ON public.ticket_pool;\r\nDROP POLICY IF EXISTS \"Admins manage tickets\" ON public.ticket_pool;\r\n\r\n-- PROFILES\r\nCREATE POLICY \"Users can view own profile\" ON public.profiles FOR SELECT USING (auth.uid() = id);\r\nCREATE POLICY \"Users can update own profile\" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);\r\n-- Fix: Use function to avoid recursion\r\nCREATE POLICY \"Admins can view all profiles\" ON public.profiles FOR SELECT USING (public.get_my_admin_status() = true);\r\nCREATE POLICY \"Admins can update any profile\" ON public.profiles FOR UPDATE USING (public.get_my_admin_status() = true);\r\n\r\n-- EVENTS\r\nCREATE POLICY \"Anyone can view active events\" ON public.events FOR SELECT USING (status = 'ACTIVE');\r\nCREATE POLICY \"Admins can view all events\" ON public.events FOR SELECT USING (public.get_my_admin_status() = true);\r\nCREATE POLICY \"Admins can insert events\" ON public.events FOR INSERT WITH CHECK (public.get_my_admin_status() = true);\r\nCREATE POLICY \"Admins can update events\" ON public.events FOR UPDATE USING (public.get_my_admin_status() = true);\r\nCREATE POLICY \"Admins can delete events\" ON public.events FOR DELETE USING (public.get_my_admin_status() = true);\r\n\r\n-- BOOKINGS\r\nCREATE POLICY \"Users view own bookings\" ON public.bookings FOR SELECT USING (auth.uid() = user_id);\r\nCREATE POLICY \"Admins manage all bookings\" ON public.bookings FOR ALL USING (public.get_my_admin_status() = true);\r\n\r\n-- TICKET POOL\r\nCREATE POLICY \"Users view assigned ticket\" ON public.ticket_pool FOR SELECT USING (assigned_to = auth.uid());\r\nCREATE POLICY \"Admins manage tickets\" ON public.ticket_pool FOR ALL USING (public.get_my_admin_status() = true);\r\n\r\n-- TICKETS (Legacy)\r\nCREATE POLICY \"Users can view own tickets\" ON public.tickets FOR SELECT USING (auth.uid() = user_id);\r\nCREATE POLICY \"Admins can view all tickets\" ON public.tickets FOR SELECT USING (public.get_my_admin_status() = true);\r\n"}