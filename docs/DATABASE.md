# Veritabanı Dokümantasyonu

Bu doküman, TALPA Etkinlik Platformu'nun revize edilmiş veritabanı şeması, RPC fonksiyonları ve iş kurallarını açıklar.

**Not:** Bu doküman SRS.md ve veritabani.md'deki yeni gereksinimlere göre güncellenmiştir. Eski sistemdeki `tickets` tablosu yerine `bookings` ve `ticket_pool` tabloları kullanılmaktadır.

## İçindekiler

- [Veritabanı Şeması](#veritabanı-şeması)
- [RPC Fonksiyonları](#rpc-fonksiyonları)
- [Row Level Security (RLS)](#row-level-security-rls)
- [İş Kuralları](#iş-kuralları)
- [İlişkiler](#ilişkiler)
- [Migrasyon Notları](#migrasyon-notları)

## Veritabanı Şeması

Veritabanı PostgreSQL üzerinde çalışır ve Supabase tarafından yönetilir. Tüm tablolar ilişkisel veri bütünlüğünü (Referential Integrity) koruyacak şekilde normalize edilmiştir.

### `profiles` Tablosu

Kullanıcı profil bilgilerini tutar. `auth.users` tablosu ile `id` üzerinden 1:1 ilişkilidir.

**Alanlar:**

| Alan | Tip | Açıklama | Kısıtlamalar |
|------|-----|----------|--------------|
| `id` | `uuid` | Kullanıcı ID'si (PK, FK → auth.users.id) | PRIMARY KEY, NOT NULL |
| `full_name` | `text` | Kullanıcının tam adı | NOT NULL |
| `tckn` | `text` | TC Kimlik No | UNIQUE, NULL (Excel import ile doldurulur) |
| `sicil_no` | `text` | Dernek Sicil No | UNIQUE, NULL (Excel import ile doldurulur) |
| `email` | `text` | E-posta adresi | UNIQUE, NOT NULL |
| `is_admin` | `boolean` | Admin yetkisi | DEFAULT false |
| `created_at` | `timestamptz` | Oluşturulma tarihi | DEFAULT now() |

**Kritik Alanlar:**
- `tckn`, `sicil_no`, `email`: Unique constraint ile çakışma kontrolü
- `is_admin`: Admin yetkisi kontrolü için kullanılır

**Örnek Veri:**
```sql
INSERT INTO profiles (id, full_name, tckn, sicil_no, email, is_admin)
VALUES ('user-uuid-123', 'Ahmet Yılmaz', '12345678901', 'MEMBER001', 'ahmet@example.com', false);
```

---

### `events` Tablosu

Etkinlik bilgilerini tutar.

**Alanlar:**

| Alan | Tip | Açıklama | Kısıtlamalar |
|------|-----|----------|--------------|
| `id` | `bigint` | Etkinlik ID'si (PK) | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY |
| `title` | `text` | Etkinlik başlığı | NOT NULL |
| `description` | `text` | Etkinlik açıklaması | NULL |
| `event_date` | `timestamptz` | Etkinlik tarihi ve saati | NOT NULL |
| `location_url` | `text` | Etkinlik konumu (Google Maps URL) | NULL |
| `price` | `numeric(10,2)` | Bilet fiyatı | DEFAULT 0 |
| `quota_asil` | `integer` | Asil liste kontenjanı | NOT NULL |
| `quota_yedek` | `integer` | Yedek liste kontenjanı | NOT NULL |
| `cut_off_date` | `timestamptz` | Son iptal tarihi | NOT NULL |
| `status` | `event_status` | Etkinlik durumu | DEFAULT 'DRAFT' |
| `banner_image` | `text` | Afiş görseli (Storage path) | NULL |
| `created_at` | `timestamptz` | Oluşturulma tarihi | DEFAULT now() |

**Enum Değerleri (`event_status`):**
- `'DRAFT'` - Taslak
- `'ACTIVE'` - Aktif (Yayında)
- `'ARCHIVED'` - Arşivlenmiş

**Kritik Alanlar:**
- `status = 'ACTIVE'`: Sistemde o an hangi etkinliğin "Yayında" olduğunu belirler. Aynı anda sadece bir etkinlik aktif olabilir (iş kuralı).
- `cut_off_date`: Bu tarihten sonra üye iptal yapamaz.

**Örnek Veri:**
```sql
INSERT INTO events (title, event_date, location_url, price, quota_asil, quota_yedek, cut_off_date, status, banner_image)
VALUES (
  'TALPA Yıllık Toplantısı',
  '2025-06-15 19:00:00+03',
  'https://maps.google.com/...',
  500.00,
  50,  -- Asil kota
  30,  -- Yedek kota
  '2025-06-10 23:59:59+03',  -- Cut-off tarihi
  'ACTIVE',
  'event-banners/banner-2025.jpg'
);
```

---

### `bookings` Tablosu

Etkinlik başvurularını ve kuyruk durumunu tutar.

**Alanlar:**

| Alan | Tip | Açıklama | Kısıtlamalar |
|------|-----|----------|--------------|
| `id` | `bigint` | Başvuru ID'si (PK) | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY |
| `event_id` | `bigint` | Etkinlik ID'si (FK) | NOT NULL, FOREIGN KEY → events.id |
| `user_id` | `uuid` | Kullanıcı ID'si (FK) | NOT NULL, FOREIGN KEY → profiles.id |
| `booking_date` | `timestamptz` | Başvuru tarihi (sıralama için) | DEFAULT now() |
| `queue_status` | `queue_status` | Kuyruk durumu | NOT NULL |
| `payment_status` | `payment_status` | Ödeme durumu | DEFAULT 'WAITING' |
| `consent_kvkk` | `boolean` | KVKK onayı | DEFAULT false |
| `consent_payment` | `boolean` | Ödeme onayı | DEFAULT false |
| `created_at` | `timestamptz` | Oluşturulma tarihi | DEFAULT now() |
| `updated_at` | `timestamptz` | Güncellenme tarihi | DEFAULT now() |

**Enum Değerleri:**
- `queue_status`: `'ASIL'`, `'YEDEK'`, `'IPTAL'`
- `payment_status`: `'WAITING'`, `'PAID'`

**Kritik Constraint:**
- `UNIQUE(event_id, user_id)`: Bir kullanıcı bir etkinliğe sadece bir başvuru yapabilir

**Örnek Veri:**
```sql
INSERT INTO bookings (event_id, user_id, queue_status, payment_status, consent_kvkk, consent_payment)
VALUES (
  1,
  'user-uuid-456',
  'ASIL',
  'WAITING',
  true,
  true
);
```

---

### `ticket_pool` Tablosu

PDF bilet havuzunu tutar. Admin tarafından yüklenen PDF dosyaları burada saklanır.

**Alanlar:**

| Alan | Tip | Açıklama | Kısıtlamalar |
|------|-----|----------|--------------|
| `id` | `bigint` | Bilet ID'si (PK) | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY |
| `event_id` | `bigint` | Etkinlik ID'si (FK) | NOT NULL, FOREIGN KEY → events.id |
| `file_name` | `text` | Dosya adı (A1.pdf, A2.pdf...) | NOT NULL (sıralama için önemli) |
| `file_path` | `text` | Supabase Storage path | NOT NULL |
| `assigned_to` | `uuid` | Atanan kullanıcı ID'si (FK) | NULL, FOREIGN KEY → profiles.id |
| `assigned_at` | `timestamptz` | Atanma tarihi | NULL |
| `is_assigned` | `boolean` | Atanma durumu | DEFAULT false |
| `created_at` | `timestamptz` | Oluşturulma tarihi | DEFAULT now() |

**Kritik Alanlar:**
- `file_name`: Dosya adına göre sıralama yapılır (A1.pdf → 1. bilet, A2.pdf → 2. bilet)
- `is_assigned`: Atanmamış biletler önce çekilir

**Örnek Veri:**
```sql
INSERT INTO ticket_pool (event_id, file_name, file_path)
VALUES (
  1,
  'A1.pdf',
  'tickets/event-1/A1.pdf'
);
```

---

## RPC Fonksiyonları

RPC (Remote Procedure Call) fonksiyonları, veritabanı seviyesinde çalışan PostgreSQL fonksiyonlarıdır. Bu fonksiyonlar atomik işlemler ve iş kurallarını garanti altına alır.

### `join_event`

Kuyruk sistemine başvuru yapar. Race condition'ları önler ve milisaniye bazında sıralama garantisi sağlar.

**Fonksiyon İmzası:**
```sql
CREATE OR REPLACE FUNCTION join_event(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
```

**Parametreler:**
- `event_id_param` (bigint): Başvuru yapılacak etkinliğin ID'si

**Dönüş Değeri:**
```json
{
  "status": "success" | "error",
  "queue": "ASIL" | "YEDEK",
  "message": "..."
}
```

**İş Mantığı:**
1. Kullanıcı oturum kontrolü (`auth.uid()`)
2. Etkinliği kilitle (FOR UPDATE) - Race condition koruması
3. Etkinlik aktif mi kontrol et (`status = 'ACTIVE'`)
4. Zaten başvurmuş mu kontrol et
5. Asil sayısını kontrol et, yer varsa ASIL listesine ekle
6. Yedek sayısını kontrol et, yer varsa YEDEK listesine ekle
7. Kontenjan doluysa hata döndür

**Transaction:**
Tüm işlemler tek bir database transaction içinde gerçekleşir. FOR UPDATE lock ile race condition koruması.

**Hata Durumları:**
- `{"status": "error", "message": "Giriş yapmalısınız."}` - Kullanıcı giriş yapmamış
- `{"status": "error", "message": "Etkinlik bulunamadı."}` - Etkinlik yok
- `{"status": "error", "message": "Etkinlik aktif değil."}` - Etkinlik aktif değil
- `{"status": "error", "message": "Zaten başvurunuz var."}` - Tekrar başvuru
- `{"status": "error", "message": "Kontenjan dolmuştur."}` - Kota dolu

**Örnek Kullanım:**
```sql
SELECT join_event(1);
```

**Supabase'den Çağrı:**
```typescript
const { data, error } = await supabase.rpc('join_event', {
  event_id_param: 1
});
```

---

### `assign_ticket`

Ödeme onayı sonrası bilet havuzundan sıradaki PDF'i üyeye atar.

**Fonksiyon İmzası:**
```sql
CREATE OR REPLACE FUNCTION assign_ticket(booking_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
```

**Parametreler:**
- `booking_id_param` (bigint): Bilet atanacak başvurunun ID'si

**Dönüş Değeri:**
```json
{
  "status": "success" | "error",
  "ticket_id": 123,
  "file_path": "tickets/event-1/A1.pdf",
  "message": "..."
}
```

**İş Mantığı:**
1. Admin yetki kontrolü
2. Booking'i al ve kilitle (FOR UPDATE)
3. Ödeme durumu kontrolü (`payment_status = 'WAITING'`)
4. Bilet havuzundan sıradaki atanmamış bileti bul (file_name'e göre sıralı)
5. Bileti üyeye ata
6. Booking'i PAID olarak güncelle

**Hata Durumları:**
- `{"status": "error", "message": "Yetkisiz erişim."}` - Admin değil
- `{"status": "error", "message": "Bilet stoku yetersiz."}` - Atanmamış bilet yok

**Örnek Kullanım:**
```sql
SELECT assign_ticket(1);
```

---

### `promote_from_waitlist`

İptal durumunda yedek listedeki ilk kişiyi asil listeye çıkarır.

**Fonksiyon İmzası:**
```sql
CREATE OR REPLACE FUNCTION promote_from_waitlist(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
```

**Parametreler:**
- `event_id_param` (bigint): Etkinlik ID'si

**Dönüş Değeri:**
```json
{
  "status": "success" | "info" | "error",
  "user_id": "uuid",
  "message": "..."
}
```

**İş Mantığı:**
1. Etkinliği kontrol et
2. Asil liste dolu mu kontrol et
3. İlk yedeği bul (booking_date'e göre sıralı)
4. Yedeği asile çıkar

**Örnek Kullanım:**
```sql
SELECT promote_from_waitlist(1);
```

---

## Row Level Security (RLS)

Row Level Security, Supabase'de veri erişimini satır seviyesinde kontrol eden bir güvenlik mekanizmasıdır. Her tablo için politikalar tanımlanır.

### `profiles` Tablosu RLS Politikaları

**SELECT Politikası:**
- Kullanıcılar kendi profilini görebilir: `auth.uid() = id`
- Adminler tüm profilleri görebilir: `(SELECT role FROM profiles WHERE id = auth.uid()) = 'admin'`

**UPDATE Politikası:**
- Kullanıcılar sadece kendi profilini güncelleyebilir: `auth.uid() = id`
- Adminler tüm profilleri güncelleyebilir

**INSERT Politikası:**
- Sadece sistem (RPC fonksiyonları) yeni profil oluşturabilir

---

### `events` Tablosu RLS Politikaları

**SELECT Politikası:**
- Herkes aktif etkinlikleri görebilir: `is_active = true`
- Adminler tüm etkinlikleri görebilir

**INSERT/UPDATE/DELETE Politikaları:**
- Sadece adminler etkinlik oluşturabilir, güncelleyebilir ve silebilir

---

### `bookings` Tablosu RLS Politikaları

**SELECT Politikası:**
- Kullanıcılar sadece kendi başvurularını görebilir: `auth.uid() = user_id`
- Adminler tüm başvuruları görebilir

**INSERT Politikası:**
- Sadece `join_event` RPC fonksiyonu başvuru oluşturabilir (`SECURITY DEFINER`)

**UPDATE Politikası:**
- Sadece adminler başvuru durumunu güncelleyebilir

---

### `ticket_pool` Tablosu RLS Politikaları

**SELECT Politikası:**
- Kullanıcılar sadece kendine atanan bileti görebilir: `assigned_to = auth.uid()`
- Adminler tüm biletleri görebilir

**INSERT/UPDATE Politikası:**
- Sadece adminler bilet havuzunu yönetebilir

---

## İş Kuralları

### 1. Single Active Event Prensibi

**Kural:** Sistemde aynı anda sadece bir etkinlik aktif olabilir.

**Uygulama:**
- Veritabanı seviyesinde `set_active_event` RPC fonksiyonu ile garanti altına alınmıştır
- Admin bir etkinliği aktif ettiğinde, diğer tüm etkinlikler otomatik olarak pasif yapılır
- Transaction içinde gerçekleştiği için race condition riski yoktur

**Avantajları:**
- Kullanıcı deneyimi: Karmaşıklık yok, tek odak noktası
- Performans: Sadece aktif etkinlik sorgulanır
- Basitlik: Karmaşık filtreleme ve seçim mekanizmalarına gerek yok

---

### 2. Kuyruk Yönetimi ve Race Condition Koruması

**Sorun:** 500 kişi aynı anda başvurursa kota aşımı riski ve sıralama şaşabilir.

**Çözüm:** `join_event` RPC fonksiyonu `FOR UPDATE` lock kullanır.

**Mekanizma:**
1. Transaction başlatılır
2. Etkinlik satırı kilitlenir (FOR UPDATE)
3. Mevcut asil/yedek sayıları sayılır
4. Kotalarla karşılaştırılır
5. Eğer yer varsa booking oluşturulur (milisaniye bazında timestamp)
6. Transaction commit edilir

**Garanti:**
- Aynı anda sadece bir işlem başvuru oluşturabilir
- Milisaniye bazında sıralama garantisi
- Kota aşımı imkansızdır
- Veri tutarlılığı korunur

---

### 3. Bilet Atama Algoritması

**Kural:** Biletler başvuru sırasına göre atanır.

**Uygulama:**
- `assign_ticket` fonksiyonu bilet havuzundan `file_name`'e göre sıralı çeker
- İlk başvuru → A1.pdf, İkinci başvuru → A2.pdf şeklinde
- Dosya adına göre sıralama: `ORDER BY file_name ASC`

---

### 4. Yedekten Asile Geçiş

**Kural:** Asil listeden biri iptal edilirse, yedek listedeki ilk kişi otomatik asile çıkar.

**Uygulama:**
- `promote_from_waitlist` fonksiyonu `booking_date`'e göre sıralı ilk yedeği bulur
- Cut-off tarihi kontrolü yapılmalı (frontend'de)
- E-posta bildirimi gönderilir (gelecekte)

---

## İlişkiler

### Foreign Key İlişkileri

```
auth.users (Supabase Auth)
    ↓ (1:1)
profiles
    ↓ (1:N)
bookings
    ↓ (1:1)
ticket_pool (assigned_to)

events
    ↓ (1:N)
bookings
    ↓ (1:N)
ticket_pool
```

**Detaylar:**

1. **profiles ↔ auth.users**
   - `profiles.id` → `auth.users.id`
   - 1:1 ilişki
   - Kullanıcı oluşturulduğunda profil otomatik oluşturulmalı

2. **events ↔ bookings**
   - `bookings.event_id` → `events.id`
   - 1:N ilişki
   - Bir etkinlikte birden fazla başvuru olabilir
   - Etkinlik silinirse başvurular cascade delete edilir

3. **profiles ↔ bookings**
   - `bookings.user_id` → `profiles.id`
   - 1:N ilişki
   - Bir kullanıcının birden fazla başvurusu olabilir
   - UNIQUE constraint: Bir kullanıcı bir etkinliğe sadece bir başvuru yapabilir

4. **events ↔ ticket_pool**
   - `ticket_pool.event_id` → `events.id`
   - 1:N ilişki
   - Bir etkinlikte birden fazla bilet dosyası olabilir

5. **profiles ↔ ticket_pool**
   - `ticket_pool.assigned_to` → `profiles.id`
   - 1:1 ilişki (atanmış biletler için)
   - Bir kullanıcıya sadece bir bilet atanabilir (etkinlik başına)

---

## Veri Bütünlüğü

### Constraints

1. **Primary Keys:** 
   - `profiles`: UUID (auth.users ile aynı)
   - `events`, `bookings`, `ticket_pool`: BIGINT (IDENTITY)
2. **Foreign Keys:** Referential integrity garantisi
3. **Unique Constraints:** 
   - `profiles.tckn`, `profiles.sicil_no`, `profiles.email`
   - `bookings(event_id, user_id)` - Bir kullanıcı bir etkinliğe tek başvuru
4. **Check Constraints:** 
   - `price >= 0`
   - `quota_asil > 0`, `quota_yedek >= 0`

### Triggers (Opsiyonel)

Gelecekte eklenebilecek trigger'lar:
- `updated_at` otomatik güncelleme
- Profil oluşturma trigger'ı (auth.users'dan)
- Bilet durumu değişikliği loglama

---

## Performans Optimizasyonları

### İndeksler

**Önerilen İndeksler:**

```sql
-- Etkinlik sorguları için
CREATE INDEX idx_events_status ON events(status) WHERE status = 'ACTIVE';

-- Booking sorguları için
CREATE INDEX idx_bookings_event_id ON bookings(event_id);
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_queue_status ON bookings(event_id, queue_status);
CREATE INDEX idx_bookings_booking_date ON bookings(event_id, booking_date ASC); -- Sıralama için

-- Ticket pool sorguları için
CREATE INDEX idx_ticket_pool_event_id ON ticket_pool(event_id);
CREATE INDEX idx_ticket_pool_unassigned ON ticket_pool(event_id, is_assigned) WHERE is_assigned = false;
CREATE INDEX idx_ticket_pool_file_name ON ticket_pool(event_id, file_name ASC); -- Sıralama için

-- Profil sorguları için
CREATE INDEX idx_profiles_is_admin ON profiles(is_admin) WHERE is_admin = true;
CREATE INDEX idx_profiles_tckn ON profiles(tckn);
CREATE INDEX idx_profiles_sicil_no ON profiles(sicil_no);
```

---

## Backup ve Recovery

### Backup Stratejisi

1. **Günlük Otomatik Backup:** Supabase otomatik olarak günlük backup alır
2. **Manuel Backup:** Supabase Dashboard'dan manuel backup alınabilir
3. **Schema Backup:** SQL dosyaları version control'de tutulmalı

### Recovery Senaryoları

1. **Veri Kaybı:** Supabase point-in-time recovery özelliği kullanılabilir
2. **Schema Değişikliği:** Migration script'leri ile geri alınabilir

---

## Migrasyon Notları

### Eski Sistemden Yeni Sisteme Geçiş

Eski sistemde `tickets` tablosu kullanılıyordu. Yeni sistemde:
- `tickets` → `bookings` (başvurular için)
- `ticket_pool` (yeni tablo, PDF bilet havuzu için)

Detaylı migrasyon adımları için `docs/MIGRATION_GUIDE.md` dosyasına bakın.

### Önemli Değişiklikler

1. **ID Tipi:** `events` tablosu UUID'den BIGINT'e geçti
2. **Kota Yönetimi:** `total_quota` → `quota_asil` + `quota_yedek`
3. **Durum Yönetimi:** `is_active` boolean → `status` enum
4. **Bilet Sistemi:** QR kodlu biletler → PDF bilet havuzu

---

**Son Güncelleme:** 2025-01-XX

