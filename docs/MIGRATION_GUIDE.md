# Veritabanı Migrasyon Rehberi

Bu doküman, mevcut veritabanı şemasını SRS.md ve veritabani.md'deki yeni gereksinimlere göre güncellemek için adım adım rehberdir.

## İçindekiler

- [Genel Bakış](#genel-bakış)
- [Ön Hazırlık](#ön-hazırlık)
- [Adım Adım Migrasyon](#adım-adım-migrasyon)
- [Veri Migrasyonu](#veri-migrasyonu)
- [Geri Alma Planı](#geri-alma-planı)
- [Doğrulama](#doğrulama)

## Genel Bakış

### Mevcut Durum

Mevcut veritabanı şeması:
- `events` tablosu: `total_quota`, `is_active` alanları ile
- `tickets` tablosu: QR kod ve status ile
- `profiles` tablosu: Basit profil yapısı

### Hedef Durum

Yeni gereksinimlere göre:
- `events` tablosu: `quota_asil`, `quota_yedek`, `cut_off_date`, `status` enum ile
- `bookings` tablosu: Kuyruk sistemi (ASIL/YEDEK), ödeme durumu, onaylar
- `ticket_pool` tablosu: PDF bilet havuzu yönetimi
- `profiles` tablosu: `tckn`, `sicil_no` alanları eklenecek

## Ön Hazırlık

### 1. Backup Alın

**Supabase Dashboard'dan:**
1. Settings → Database → Backups
2. "Create Backup" butonuna tıklayın
3. Backup'ın tamamlanmasını bekleyin

**Veya SQL ile:**
```sql
-- Tüm tabloları export et
pg_dump -h [host] -U [user] -d [database] > backup_$(date +%Y%m%d).sql
```

### 2. Test Ortamında Deneyin

**ÖNEMLİ:** Önce test/staging ortamında tüm migrasyon adımlarını uygulayın.

### 3. Bakım Penceresi Planlayın

Migrasyon sırasında sistem kullanılamayacaktır. Kullanıcılara önceden bildirim yapın.

## Adım Adım Migrasyon

### Adım 1: Yeni Enum Tipleri Oluştur

```sql
-- Supabase SQL Editor'de çalıştırın

-- 1. Event Status Enum
CREATE TYPE event_status AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');

-- 2. Queue Status Enum
CREATE TYPE queue_status AS ENUM ('ASIL', 'YEDEK', 'IPTAL');

-- 3. Payment Status Enum
CREATE TYPE payment_status AS ENUM ('WAITING', 'PAID');
```

**Doğrulama:**
```sql
SELECT typname FROM pg_type WHERE typname IN ('event_status', 'queue_status', 'payment_status');
```

### Adım 2: Profiles Tablosunu Güncelle

```sql
-- Mevcut profiles tablosuna yeni alanlar ekle

ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS tckn TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS sicil_no TEXT UNIQUE;

-- Mevcut veriler için geçici değerler (gerekirse)
-- UPDATE public.profiles SET tckn = 'TEMP_' || id WHERE tckn IS NULL;
-- UPDATE public.profiles SET sicil_no = talpa_sicil_no WHERE sicil_no IS NULL AND talpa_sicil_no IS NOT NULL;

-- Eski alanları kaldırma (opsiyonel, önce kontrol edin)
-- ALTER TABLE public.profiles DROP COLUMN IF EXISTS talpa_sicil_no;
-- ALTER TABLE public.profiles DROP COLUMN IF EXISTS phone;
```

**Not:** Mevcut verileriniz varsa, Excel import işlemi ile `tckn` ve `sicil_no` alanlarını doldurabilirsiniz.

### Adım 3: Events Tablosunu Güncelle

```sql
-- Yeni alanları ekle
ALTER TABLE public.events
ADD COLUMN IF NOT EXISTS quota_asil INT,
ADD COLUMN IF NOT EXISTS quota_yedek INT,
ADD COLUMN IF NOT EXISTS cut_off_date TIMESTAMPTZ,
ADD COLUMN IF NOT EXISTS status event_status DEFAULT 'DRAFT',
ADD COLUMN IF NOT EXISTS banner_image TEXT;

-- Mevcut verileri migrate et
UPDATE public.events
SET 
  quota_asil = total_quota,
  quota_yedek = 0,
  status = CASE 
    WHEN is_active = true THEN 'ACTIVE'::event_status
    ELSE 'DRAFT'::event_status
  END,
  cut_off_date = event_date - INTERVAL '7 days' -- Varsayılan: Etkinlikten 7 gün önce
WHERE quota_asil IS NULL;

-- NOT NULL constraint'leri ekle (veriler migrate edildikten sonra)
ALTER TABLE public.events
ALTER COLUMN quota_asil SET NOT NULL,
ALTER COLUMN quota_yedek SET NOT NULL,
ALTER COLUMN cut_off_date SET NOT NULL;

-- Eski alanları kaldırma (opsiyonel, önce kontrol edin)
-- ALTER TABLE public.events DROP COLUMN IF EXISTS total_quota;
-- ALTER TABLE public.events DROP COLUMN IF EXISTS is_active;
-- ALTER TABLE public.events DROP COLUMN IF EXISTS image_url; -- banner_image'e taşındı
```

### Adım 4: Ticket Pool Tablosunu Oluştur

```sql
-- Yeni ticket_pool tablosu
CREATE TABLE IF NOT EXISTS public.ticket_pool (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
  file_name TEXT NOT NULL,
  file_path TEXT NOT NULL,
  assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  assigned_at TIMESTAMPTZ,
  is_assigned BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- İndeksler
CREATE INDEX IF NOT EXISTS idx_ticket_pool_event_id ON public.ticket_pool(event_id);
CREATE INDEX IF NOT EXISTS idx_ticket_pool_assigned ON public.ticket_pool(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_ticket_pool_unassigned ON public.ticket_pool(event_id, is_assigned) WHERE is_assigned = false;
```

### Adım 5: Bookings Tablosunu Oluştur

```sql
-- Yeni bookings tablosu
CREATE TABLE IF NOT EXISTS public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  booking_date TIMESTAMPTZ DEFAULT NOW(),
  queue_status queue_status NOT NULL,
  payment_status payment_status DEFAULT 'WAITING',
  consent_kvkk BOOLEAN DEFAULT FALSE,
  consent_payment BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Bir kişi bir etkinliğe tek başvuru yapabilir
  UNIQUE(event_id, user_id)
);

-- İndeksler
CREATE INDEX IF NOT EXISTS idx_bookings_event_id ON public.bookings(event_id);
CREATE INDEX IF NOT EXISTS idx_bookings_user_id ON public.bookings(user_id);
CREATE INDEX IF NOT EXISTS idx_bookings_queue_status ON public.bookings(event_id, queue_status);
CREATE INDEX IF NOT EXISTS idx_bookings_booking_date ON public.bookings(event_id, booking_date ASC); -- Sıralama için
```

### Adım 6: RPC Fonksiyonlarını Oluştur

```sql
-- join_event fonksiyonu (veritabani.md'den)
CREATE OR REPLACE FUNCTION join_event(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_asil_count INT;
  current_yedek_count INT;
  event_record RECORD;
  user_id_var UUID;
BEGIN
  -- 1. Kullanıcıyı al (Oturum açmış kişi)
  user_id_var := auth.uid();
  IF user_id_var IS NULL THEN
    RETURN json_build_object('status', 'error', 'message', 'Giriş yapmalısınız.');
  END IF;

  -- 2. Etkinliği ve Kotaları Kilitle (ROW LOCKING - FOR UPDATE)
  SELECT * INTO event_record FROM public.events WHERE id = event_id_param FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik bulunamadı.');
  END IF;

  IF event_record.status != 'ACTIVE' THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik aktif değil.');
  END IF;

  -- 3. Zaten başvurmuş mu?
  IF EXISTS (SELECT 1 FROM public.bookings WHERE event_id = event_id_param AND user_id = user_id_var) THEN
    RETURN json_build_object('status', 'error', 'message', 'Zaten başvurunuz var.');
  END IF;

  -- 4. Asil Sayımı
  SELECT COUNT(*) INTO current_asil_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'ASIL';

  IF current_asil_count < event_record.quota_asil THEN
    -- Asil Listesine Ekle
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'ASIL', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'ASIL');
  END IF;

  -- 5. Yedek Sayımı
  SELECT COUNT(*) INTO current_yedek_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'YEDEK';

  IF current_yedek_count < event_record.quota_yedek THEN
    -- Yedek Listesine Ekle
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'YEDEK', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'YEDEK');
  END IF;

  -- 6. Kota Dolu
  RETURN json_build_object('status', 'error', 'message', 'Kontenjan dolmuştur.');
END;
$$;
```

### Adım 7: Bilet Atama Fonksiyonunu Oluştur

```sql
-- assign_ticket fonksiyonu (Admin ödeme onayladığında çağrılacak)
CREATE OR REPLACE FUNCTION assign_ticket(
  booking_id_param BIGINT
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  booking_record RECORD;
  ticket_record RECORD;
  user_id_var UUID;
BEGIN
  -- 1. Admin kontrolü
  user_id_var := auth.uid();
  IF user_id_var IS NULL OR NOT EXISTS (
    SELECT 1 FROM public.profiles WHERE id = user_id_var AND is_admin = true
  ) THEN
    RETURN json_build_object('status', 'error', 'message', 'Yetkisiz erişim.');
  END IF;

  -- 2. Booking'i al ve kilitle
  SELECT * INTO booking_record FROM public.bookings 
  WHERE id = booking_id_param AND payment_status = 'WAITING'
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Başvuru bulunamadı veya zaten ödendi.');
  END IF;

  -- 3. Sıradaki atanmamış bileti bul (dosya adına göre sıralı)
  SELECT * INTO ticket_record FROM public.ticket_pool
  WHERE event_id = booking_record.event_id 
    AND is_assigned = false
  ORDER BY file_name ASC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Bilet stoku yetersiz.');
  END IF;

  -- 4. Bileti ata
  UPDATE public.ticket_pool
  SET 
    assigned_to = booking_record.user_id,
    assigned_at = NOW(),
    is_assigned = true
  WHERE id = ticket_record.id;

  -- 5. Booking'i güncelle
  UPDATE public.bookings
  SET payment_status = 'PAID'
  WHERE id = booking_id_param;

  RETURN json_build_object(
    'status', 'success',
    'ticket_id', ticket_record.id,
    'file_path', ticket_record.file_path
  );
END;
$$;
```

### Adım 8: Yedekten Asile Geçiş Fonksiyonu

```sql
-- promote_from_waitlist fonksiyonu (İptal durumunda çağrılacak)
CREATE OR REPLACE FUNCTION promote_from_waitlist(
  event_id_param BIGINT
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  next_waitlist_record RECORD;
  event_record RECORD;
BEGIN
  -- 1. Etkinliği al
  SELECT * INTO event_record FROM public.events WHERE id = event_id_param;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik bulunamadı.');
  END IF;

  -- 2. Asil sayısını kontrol et
  IF (SELECT COUNT(*) FROM public.bookings 
      WHERE event_id = event_id_param AND queue_status = 'ASIL') 
      >= event_record.quota_asil THEN
    RETURN json_build_object('status', 'info', 'message', 'Asil liste dolu.');
  END IF;

  -- 3. İlk yedeği bul
  SELECT * INTO next_waitlist_record FROM public.bookings
  WHERE event_id = event_id_param 
    AND queue_status = 'YEDEK'
  ORDER BY booking_date ASC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'info', 'message', 'Yedek liste boş.');
  END IF;

  -- 4. Yedeği asile çıkar
  UPDATE public.bookings
  SET queue_status = 'ASIL'
  WHERE id = next_waitlist_record.id;

  RETURN json_build_object(
    'status', 'success',
    'user_id', next_waitlist_record.user_id,
    'message', 'Yedek listeden asile çıkarıldı.'
  );
END;
$$;
```

### Adım 9: RLS Politikalarını Güncelle

```sql
-- RLS'i aktif et
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_pool ENABLE ROW LEVEL SECURITY;

-- Profiles politikaları
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can view all profiles" ON public.profiles;
CREATE POLICY "Admins can view all profiles" ON public.profiles
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- Bookings politikaları
DROP POLICY IF EXISTS "Users view own bookings" ON public.bookings;
CREATE POLICY "Users view own bookings" ON public.bookings
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Admins manage all bookings" ON public.bookings;
CREATE POLICY "Admins manage all bookings" ON public.bookings
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- Ticket Pool politikaları
DROP POLICY IF EXISTS "Users view assigned ticket" ON public.ticket_pool;
CREATE POLICY "Users view assigned ticket" ON public.ticket_pool
  FOR SELECT USING (assigned_to = auth.uid());

DROP POLICY IF EXISTS "Admins manage tickets" ON public.ticket_pool;
CREATE POLICY "Admins manage tickets" ON public.ticket_pool
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );
```

### Adım 10: Storage Bucket'larını Oluştur

Supabase Dashboard'dan:

1. **Storage** → **Buckets** → **New Bucket**
   - Name: `event-banners`
   - Public: `Yes` (Afişleri herkes görebilmeli)

2. **Storage** → **Buckets** → **New Bucket**
   - Name: `tickets`
   - Public: `No` (Gizli, sadece yetkili indirebilmeli)

## Veri Migrasyonu

### Mevcut Tickets Verilerini Bookings'e Taşıma

Eğer mevcut `tickets` tablosunda verileriniz varsa:

```sql
-- Mevcut tickets'ları bookings'e migrate et
INSERT INTO public.bookings (event_id, user_id, booking_date, queue_status, payment_status, consent_kvkk, consent_payment)
SELECT 
  event_id,
  user_id,
  purchase_date,
  CASE 
    WHEN status = 'paid' THEN 'ASIL'::queue_status
    WHEN status = 'cancelled' THEN 'IPTAL'::queue_status
    ELSE 'ASIL'::queue_status
  END,
  CASE 
    WHEN status = 'paid' THEN 'PAID'::payment_status
    ELSE 'WAITING'::payment_status
  END,
  true, -- consent_kvkk
  true  -- consent_payment
FROM public.tickets
WHERE status != 'cancelled'
ON CONFLICT (event_id, user_id) DO NOTHING;
```

## Geri Alma Planı

Eğer bir sorun çıkarsa:

```sql
-- 1. Yeni tabloları sil
DROP TABLE IF EXISTS public.bookings CASCADE;
DROP TABLE IF EXISTS public.ticket_pool CASCADE;

-- 2. Enum'ları sil
DROP TYPE IF EXISTS queue_status CASCADE;
DROP TYPE IF EXISTS payment_status CASCADE;
DROP TYPE IF EXISTS event_status CASCADE;

-- 3. Events tablosunu geri al
ALTER TABLE public.events
DROP COLUMN IF EXISTS quota_asil,
DROP COLUMN IF EXISTS quota_yedek,
DROP COLUMN IF EXISTS cut_off_date,
DROP COLUMN IF EXISTS status,
DROP COLUMN IF EXISTS banner_image;

-- 4. Profiles tablosunu geri al
ALTER TABLE public.profiles
DROP COLUMN IF EXISTS tckn,
DROP COLUMN IF EXISTS sicil_no;
```

## Doğrulama

### 1. Tablo Kontrolleri

```sql
-- Tüm tablolar var mı?
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('events', 'bookings', 'ticket_pool', 'profiles');

-- Enum'lar var mı?
SELECT typname FROM pg_type 
WHERE typname IN ('event_status', 'queue_status', 'payment_status');
```

### 2. Fonksiyon Kontrolleri

```sql
-- RPC fonksiyonları var mı?
SELECT routine_name FROM information_schema.routines
WHERE routine_schema = 'public'
AND routine_name IN ('join_event', 'assign_ticket', 'promote_from_waitlist');
```

### 3. RLS Kontrolleri

```sql
-- RLS aktif mi?
SELECT tablename, rowsecurity FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('bookings', 'ticket_pool', 'profiles');
```

### 4. Test Senaryoları

```sql
-- Test 1: join_event fonksiyonunu test et
SELECT join_event(1); -- event_id'yi gerçek ID ile değiştirin

-- Test 2: Booking oluşturma
INSERT INTO public.bookings (event_id, user_id, queue_status)
VALUES (1, 'user-uuid', 'ASIL');

-- Test 3: Ticket pool'a dosya ekleme
INSERT INTO public.ticket_pool (event_id, file_name, file_path)
VALUES (1, 'A1.pdf', 'tickets/event-1/A1.pdf');
```

## Sonraki Adımlar

1. ✅ Veritabanı migrasyonu tamamlandı
2. ⏭️ TypeScript tip tanımlarını güncelle (`src/types/supabase.ts`)
3. ⏭️ Server Actions'ları güncelle
4. ⏭️ Frontend component'lerini güncelle
5. ⏭️ Test et

**Son Güncelleme:** 2025-01-XX

