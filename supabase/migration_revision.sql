-- ============================================
-- TALPA Etkinlik Platform - Revision Migration
-- ============================================
-- Description: Migrates from ticket purchase system to queue-based booking system
-- Version: 2.0.0
-- Date: 2025-01-XX
-- 
-- IMPORTANT: This migration should be run in Supabase SQL Editor
-- Backup your database before running this migration!
-- ============================================

-- ============================================
-- STEP 1: Create Enum Types
-- ============================================

-- Event Status Enum
DO $$ BEGIN
    CREATE TYPE event_status AS ENUM ('DRAFT', 'ACTIVE', 'ARCHIVED');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Queue Status Enum
DO $$ BEGIN
    CREATE TYPE queue_status AS ENUM ('ASIL', 'YEDEK', 'IPTAL');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Payment Status Enum
DO $$ BEGIN
    CREATE TYPE payment_status AS ENUM ('WAITING', 'PAID');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================
-- STEP 2: Update Profiles Table
-- ============================================

-- Add new columns
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS tckn TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS sicil_no TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS email TEXT UNIQUE,
ADD COLUMN IF NOT EXISTS is_admin BOOLEAN DEFAULT FALSE;

-- Migrate role to is_admin (if role column exists)
UPDATE public.profiles
SET is_admin = CASE 
    WHEN role = 'admin' THEN true
    ELSE false
END
WHERE is_admin IS NULL AND role IS NOT NULL;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_profiles_tckn ON public.profiles(tckn) WHERE tckn IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_sicil_no ON public.profiles(sicil_no) WHERE sicil_no IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_profiles_is_admin ON public.profiles(is_admin) WHERE is_admin = true;

-- ============================================
-- STEP 3: Create New Events Table Structure
-- ============================================
-- Note: We'll create a new table and migrate data, then rename

-- Create new events table with BIGINT id
CREATE TABLE IF NOT EXISTS public.events_new (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    banner_image TEXT,
    event_date TIMESTAMPTZ NOT NULL,
    location_url TEXT,
    price NUMERIC(10, 2) DEFAULT 0,
    quota_asil INT NOT NULL,
    quota_yedek INT NOT NULL,
    cut_off_date TIMESTAMPTZ NOT NULL,
    status event_status DEFAULT 'DRAFT',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Migrate data from old events table
INSERT INTO public.events_new (
    title, description, banner_image, event_date, location_url, price,
    quota_asil, quota_yedek, cut_off_date, status, created_at, updated_at
)
SELECT 
    title,
    description,
    image_url as banner_image,
    event_date,
    location as location_url,
    price,
    COALESCE(total_quota, 0) as quota_asil,
    0 as quota_yedek,
    event_date - INTERVAL '7 days' as cut_off_date,
    CASE 
        WHEN is_active = true THEN 'ACTIVE'::event_status
        ELSE 'DRAFT'::event_status
    END as status,
    created_at,
    updated_at
FROM public.events
ON CONFLICT DO NOTHING;

-- Drop old events table dependencies first
DROP VIEW IF EXISTS public.active_event_view CASCADE;
DROP FUNCTION IF EXISTS public.get_remaining_stock(UUID) CASCADE;
DROP FUNCTION IF EXISTS public.purchase_ticket(UUID) CASCADE;
DROP FUNCTION IF EXISTS public.set_active_event(UUID) CASCADE;
DROP FUNCTION IF EXISTS public.get_event_stats(UUID) CASCADE;
DROP FUNCTION IF EXISTS public.get_user_tickets() CASCADE;
DROP FUNCTION IF EXISTS public.cancel_ticket(UUID) CASCADE;

-- Drop foreign key constraints from dependent tables
ALTER TABLE IF EXISTS public.tickets DROP CONSTRAINT IF EXISTS tickets_event_id_fkey;
ALTER TABLE IF EXISTS public.requests DROP CONSTRAINT IF EXISTS requests_event_id_fkey;

-- Rename tables
ALTER TABLE public.events RENAME TO events_old;
ALTER TABLE public.events_new RENAME TO events;

-- Create indexes for new events table
CREATE INDEX IF NOT EXISTS idx_events_status ON public.events(status) WHERE status = 'ACTIVE';
CREATE INDEX IF NOT EXISTS idx_events_date ON public.events(event_date);

-- Recreate trigger for updated_at
CREATE TRIGGER set_events_updated_at
    BEFORE UPDATE ON public.events
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- ============================================
-- STEP 4: Create Bookings Table
-- ============================================

CREATE TABLE IF NOT EXISTS public.bookings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    booking_date TIMESTAMPTZ DEFAULT NOW(),
    queue_status queue_status NOT NULL,
    payment_status payment_status DEFAULT 'WAITING',
    consent_kvkk BOOLEAN DEFAULT FALSE,
    consent_payment BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- One booking per user per event
    UNIQUE(event_id, user_id)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_bookings_event_id ON public.bookings(event_id);
CREATE INDEX IF NOT EXISTS idx_bookings_user_id ON public.bookings(user_id);
CREATE INDEX IF NOT EXISTS idx_bookings_queue_status ON public.bookings(event_id, queue_status);
CREATE INDEX IF NOT EXISTS idx_bookings_booking_date ON public.bookings(event_id, booking_date ASC);

-- Add trigger for updated_at
CREATE TRIGGER set_bookings_updated_at
    BEFORE UPDATE ON public.bookings
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- ============================================
-- STEP 5: Create Ticket Pool Table
-- ============================================

CREATE TABLE IF NOT EXISTS public.ticket_pool (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_id BIGINT REFERENCES public.events(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL,
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ,
    is_assigned BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_ticket_pool_event_id ON public.ticket_pool(event_id);
CREATE INDEX IF NOT EXISTS idx_ticket_pool_assigned ON public.ticket_pool(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_ticket_pool_unassigned ON public.ticket_pool(event_id, is_assigned) WHERE is_assigned = false;
CREATE INDEX IF NOT EXISTS idx_ticket_pool_file_name ON public.ticket_pool(event_id, file_name ASC);

-- ============================================
-- STEP 6: Migrate Data from Old Tables
-- ============================================

-- Migrate tickets to bookings (if tickets table exists)
INSERT INTO public.bookings (event_id, user_id, booking_date, queue_status, payment_status, consent_kvkk, consent_payment, created_at)
SELECT 
    (SELECT id FROM public.events WHERE title = (SELECT title FROM public.events_old WHERE id = t.event_id) LIMIT 1),
    t.user_id,
    t.purchase_date,
    CASE 
        WHEN t.status = 'paid' THEN 'ASIL'::queue_status
        WHEN t.status = 'cancelled' THEN 'IPTAL'::queue_status
        ELSE 'ASIL'::queue_status
    END,
    CASE 
        WHEN t.status = 'paid' THEN 'PAID'::payment_status
        ELSE 'WAITING'::payment_status
    END,
    true,
    true,
    t.created_at
FROM public.tickets t
WHERE t.status != 'cancelled'
ON CONFLICT (event_id, user_id) DO NOTHING;

-- Migrate requests to bookings (if requests table exists)
INSERT INTO public.bookings (event_id, user_id, booking_date, queue_status, payment_status, consent_kvkk, consent_payment, created_at)
SELECT 
    (SELECT id FROM public.events WHERE title = (SELECT title FROM public.events_old WHERE id = r.event_id) LIMIT 1),
    r.user_id,
    r.created_at,
    CASE 
        WHEN r.status = 'approved' THEN 'ASIL'::queue_status
        WHEN r.status = 'waitlist' THEN 'YEDEK'::queue_status
        WHEN r.status = 'rejected' THEN 'IPTAL'::queue_status
        ELSE 'ASIL'::queue_status
    END,
    'WAITING'::payment_status,
    true,
    true,
    r.created_at
FROM public.requests r
ON CONFLICT (event_id, user_id) DO NOTHING;

-- ============================================
-- STEP 7: Create RPC Functions
-- ============================================

-- join_event function
CREATE OR REPLACE FUNCTION join_event(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_asil_count INT;
  current_yedek_count INT;
  event_record RECORD;
  user_id_var UUID;
BEGIN
  -- 1. Get current user
  user_id_var := auth.uid();
  IF user_id_var IS NULL THEN
    RETURN json_build_object('status', 'error', 'message', 'Giriş yapmalısınız.');
  END IF;

  -- 2. Lock event row (FOR UPDATE prevents race conditions)
  SELECT * INTO event_record FROM public.events WHERE id = event_id_param FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik bulunamadı.');
  END IF;

  IF event_record.status != 'ACTIVE' THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik aktif değil.');
  END IF;

  -- 3. Check if user already has a booking
  IF EXISTS (SELECT 1 FROM public.bookings WHERE event_id = event_id_param AND user_id = user_id_var) THEN
    RETURN json_build_object('status', 'error', 'message', 'Zaten başvurunuz var.');
  END IF;

  -- 4. Check asil quota
  SELECT COUNT(*) INTO current_asil_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'ASIL';

  IF current_asil_count < event_record.quota_asil THEN
    -- Add to asil list
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'ASIL', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'ASIL', 'message', 'Başvurunuz alındı (ASİL).');
  END IF;

  -- 5. Check yedek quota
  SELECT COUNT(*) INTO current_yedek_count FROM public.bookings 
  WHERE event_id = event_id_param AND queue_status = 'YEDEK';

  IF current_yedek_count < event_record.quota_yedek THEN
    -- Add to yedek list
    INSERT INTO public.bookings (event_id, user_id, queue_status, consent_kvkk, consent_payment)
    VALUES (event_id_param, user_id_var, 'YEDEK', true, true);
    RETURN json_build_object('status', 'success', 'queue', 'YEDEK', 'message', 'Başvurunuz alındı (YEDEK).');
  END IF;

  -- 6. Quota full
  RETURN json_build_object('status', 'error', 'message', 'Kontenjan dolmuştur.');
END;
$$;

COMMENT ON FUNCTION join_event IS 'Join event queue system with race condition protection';

-- assign_ticket function
CREATE OR REPLACE FUNCTION assign_ticket(booking_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  booking_record RECORD;
  ticket_record RECORD;
  user_id_var UUID;
BEGIN
  -- 1. Admin check
  user_id_var := auth.uid();
  IF user_id_var IS NULL OR NOT EXISTS (
    SELECT 1 FROM public.profiles WHERE id = user_id_var AND is_admin = true
  ) THEN
    RETURN json_build_object('status', 'error', 'message', 'Yetkisiz erişim.');
  END IF;

  -- 2. Get and lock booking
  SELECT * INTO booking_record FROM public.bookings 
  WHERE id = booking_id_param AND payment_status = 'WAITING'
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Başvuru bulunamadı veya zaten ödendi.');
  END IF;

  -- 3. Find next unassigned ticket (ordered by file_name)
  SELECT * INTO ticket_record FROM public.ticket_pool
  WHERE event_id = booking_record.event_id 
    AND is_assigned = false
  ORDER BY file_name ASC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Bilet stoku yetersiz.');
  END IF;

  -- 4. Assign ticket
  UPDATE public.ticket_pool
  SET 
    assigned_to = booking_record.user_id,
    assigned_at = NOW(),
    is_assigned = true
  WHERE id = ticket_record.id;

  -- 5. Update booking
  UPDATE public.bookings
  SET payment_status = 'PAID'
  WHERE id = booking_id_param;

  RETURN json_build_object(
    'status', 'success',
    'ticket_id', ticket_record.id,
    'file_path', ticket_record.file_path,
    'message', 'Bilet başarıyla atandı.'
  );
END;
$$;

COMMENT ON FUNCTION assign_ticket IS 'Assign ticket from pool to booking (admin only)';

-- promote_from_waitlist function
CREATE OR REPLACE FUNCTION promote_from_waitlist(event_id_param BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  next_waitlist_record RECORD;
  event_record RECORD;
BEGIN
  -- 1. Get event
  SELECT * INTO event_record FROM public.events WHERE id = event_id_param;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'error', 'message', 'Etkinlik bulunamadı.');
  END IF;

  -- 2. Check asil quota
  IF (SELECT COUNT(*) FROM public.bookings 
      WHERE event_id = event_id_param AND queue_status = 'ASIL') 
      >= event_record.quota_asil THEN
    RETURN json_build_object('status', 'info', 'message', 'Asil liste dolu.');
  END IF;

  -- 3. Find first yedek (ordered by booking_date)
  SELECT * INTO next_waitlist_record FROM public.bookings
  WHERE event_id = event_id_param 
    AND queue_status = 'YEDEK'
  ORDER BY booking_date ASC
  LIMIT 1
  FOR UPDATE;

  IF NOT FOUND THEN
    RETURN json_build_object('status', 'info', 'message', 'Yedek liste boş.');
  END IF;

  -- 4. Promote to asil
  UPDATE public.bookings
  SET queue_status = 'ASIL'
  WHERE id = next_waitlist_record.id;

  RETURN json_build_object(
    'status', 'success',
    'user_id', next_waitlist_record.user_id,
    'message', 'Yedek listeden asile çıkarıldı.'
  );
END;
$$;

COMMENT ON FUNCTION promote_from_waitlist IS 'Promote first yedek to asil when space opens';

-- set_active_event function (updated for new schema)
CREATE OR REPLACE FUNCTION set_active_event(p_event_id BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_is_admin BOOLEAN;
  v_event_exists BOOLEAN;
BEGIN
  -- Check if user is admin
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND is_admin = true
  ) INTO v_is_admin;
  
  IF NOT v_is_admin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Bu işlem için yetkiniz yok.'
    );
  END IF;
  
  -- Check if event exists
  SELECT EXISTS (
    SELECT 1 FROM public.events WHERE id = p_event_id
  ) INTO v_event_exists;
  
  IF NOT v_event_exists THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Etkinlik bulunamadı.'
    );
  END IF;
  
  -- Deactivate all events first (atomic transaction)
  UPDATE public.events SET status = 'ARCHIVED' WHERE status = 'ACTIVE';
  
  -- Activate the selected event
  UPDATE public.events 
  SET status = 'ACTIVE' 
  WHERE id = p_event_id;
  
  RETURN json_build_object(
    'success', true,
    'message', 'Etkinlik aktif edildi.'
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Etkinlik aktif edilirken hata oluştu: ' || SQLERRM
    );
END;
$$;

COMMENT ON FUNCTION set_active_event IS 'Set an event as active (admin only, ensures single active event)';

-- ============================================
-- STEP 8: Create RLS Policies
-- ============================================

-- Enable RLS
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_pool ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
DROP POLICY IF EXISTS "Admins can view all profiles" ON public.profiles;
DROP POLICY IF EXISTS "Users view own bookings" ON public.bookings;
DROP POLICY IF EXISTS "Admins manage all bookings" ON public.bookings;
DROP POLICY IF EXISTS "Users view assigned ticket" ON public.ticket_pool;
DROP POLICY IF EXISTS "Admins manage tickets" ON public.ticket_pool;

-- Profiles policies
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Admins can view all profiles" ON public.profiles
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- Bookings policies
CREATE POLICY "Users view own bookings" ON public.bookings
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Admins manage all bookings" ON public.bookings
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- Ticket pool policies
CREATE POLICY "Users view assigned ticket" ON public.ticket_pool
  FOR SELECT USING (assigned_to = auth.uid());

CREATE POLICY "Admins manage tickets" ON public.ticket_pool
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- Events policies (public can view active events)
CREATE POLICY "Anyone can view active events" ON public.events
  FOR SELECT USING (status = 'ACTIVE');

CREATE POLICY "Admins manage all events" ON public.events
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- ============================================
-- STEP 9: Create Active Event View
-- ============================================

CREATE OR REPLACE VIEW public.active_event_view AS
SELECT 
    e.id,
    e.title,
    e.description,
    e.banner_image as image_url,
    e.event_date,
    e.location_url as location,
    e.price,
    'TL' as currency,
    e.quota_asil + e.quota_yedek as total_quota,
    true as is_active,
    e.created_at,
    e.updated_at,
    COALESCE(
        (e.quota_asil + e.quota_yedek) - (
            SELECT COUNT(*)
            FROM public.bookings b
            WHERE b.event_id = e.id 
            AND b.queue_status IN ('ASIL', 'YEDEK')
        ), 
        e.quota_asil + e.quota_yedek
    ) AS remaining_stock
FROM public.events e
WHERE e.status = 'ACTIVE';

COMMENT ON VIEW public.active_event_view IS 'Active event with calculated remaining stock (backward compatibility)';

-- ============================================
-- Migration Complete
-- ============================================
-- 
-- Next steps:
-- 1. Verify migration by checking tables and functions
-- 2. Test RPC functions
-- 3. Update application code to use new schema
-- 4. (Optional) Drop old tables after verification:
--    DROP TABLE IF EXISTS public.events_old CASCADE;
--    DROP TABLE IF EXISTS public.tickets CASCADE;
--    DROP TABLE IF EXISTS public.requests CASCADE;
-- ============================================

